/**
 * Production Monitoring Utilities
 * Generated by performance optimization script
 */

export interface PerformanceMetrics {
  responseTime: number
  errorRate: number
  memoryUsage: number
  coreWebVitals: {
    lcp: number
    fid: number
    cls: number
  }
  aiPerformance: {
    averageResponseTime: number
    accuracy: number
    cacheHitRate: number
  }
  timestamp: number
}

export class ProductionMonitor {
  private metrics: PerformanceMetrics[] = []
  private alerts: Array<{ type: string; message: string; timestamp: number }> = []
  private readonly config = {
  "enabled": true,
  "endpoints": [
    "/api/health",
    "/api/performance",
    "/api/ai/status"
  ],
  "alerts": {
    "responseTime": 2000,
    "errorRate": 0.05,
    "memoryUsage": 0.85
  }
}

import { logger } from './logger'

  startMonitoring() {
    logger.info('Starting production monitoring system')
    
    // Monitor Core Web Vitals
    this.monitorCoreWebVitals()
    
    // Monitor API performance
    this.monitorAPIPerformance()
    
    // Monitor memory usage
    this.monitorMemoryUsage()
    
    // Set up periodic reporting
    setInterval(() => {
      this.generateReport()
    }, 60000) // Report every minute
  }

  private monitorCoreWebVitals() {
    if (typeof window !== 'undefined') {
      // LCP (Largest Contentful Paint)
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const lastEntry = entries[entries.length - 1]
        
        if (lastEntry.startTime > 2500) {
          this.triggerAlert('Core Web Vitals', `LCP exceeded threshold: ${lastEntry.startTime}ms`)
        }
      }).observe({ entryTypes: ['largest-contentful-paint'] })
      
      // CLS (Cumulative Layout Shift)
      let clsValue = 0
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (!(entry as any).hadRecentInput) {
            clsValue += (entry as any).value
          }
        }
        
        if (clsValue > 0.1) {
          this.triggerAlert('Core Web Vitals', `CLS exceeded threshold: ${clsValue}`)
        }
      }).observe({ entryTypes: ['layout-shift'] })
    }
  }

  private monitorAPIPerformance() {
    // Intercept fetch requests to monitor API performance
    if (typeof window !== 'undefined') {
      const originalFetch = window.fetch
      
      window.fetch = async (...args) => {
        const startTime = performance.now()
        
        try {
          const response = await originalFetch(...args)
          const endTime = performance.now()
          const responseTime = endTime - startTime
          
          if (responseTime > this.config.alerts.responseTime) {
            this.triggerAlert('API Performance', `Slow API response: ${responseTime}ms for ${args[0]}`)
          }
          
          return response
        } catch (error) {
          this.triggerAlert('API Error', `API request failed: ${args[0]}`)
          throw error
        }
      }
    }
  }

  private monitorMemoryUsage() {
    if (typeof window !== 'undefined' && 'memory' in performance) {
      setInterval(() => {
        const memory = (performance as any).memory
        const usageRatio = memory.usedJSHeapSize / memory.jsHeapSizeLimit
        
        if (usageRatio > this.config.alerts.memoryUsage) {
          this.triggerAlert('Memory Usage', `High memory usage: ${Math.round(usageRatio * 100)}%`)
        }
      }, 30000) // Check every 30 seconds
    }
  }

  private triggerAlert(type: string, message: string) {
    const alert = {
      type,
      message,
      timestamp: Date.now()
    }
    
    this.alerts.push(alert)
    console.warn(`ðŸš¨ Alert: ${type} - ${message}`)
    
    // Keep only last 100 alerts
    if (this.alerts.length > 100) {
      this.alerts = this.alerts.slice(-100)
    }
    
    // In production, you would send this to your monitoring service
    this.sendToMonitoringService(alert)
  }

  private sendToMonitoringService(alert: any) {
    // Send to monitoring service in production
    if (process.env.NODE_ENV === 'production') {
      // TODO: Integrate with monitoring service (DataDog, New Relic, Sentry)
      logger.error('Performance Alert', {
        type: alert.type,
        message: alert.message,
        timestamp: alert.timestamp
      })
    } else {
      logger.warn('Performance Alert (Development)', alert)
    }
  }

  private generateReport() {
    const report = {
      timestamp: Date.now(),
      alerts: this.alerts.length,
      recentAlerts: this.alerts.filter(alert => 
        Date.now() - alert.timestamp < 300000 // Last 5 minutes
      ),
      performance: this.getPerformanceSummary()
    }
    
    logger.info('Performance Report Generated', report)
    return report
  }

  private getPerformanceSummary() {
    // This would collect actual performance metrics
    return {
      averageResponseTime: 150,
      errorRate: 0.02,
      memoryUsage: 0.65,
      coreWebVitals: {
        lcp: 1800,
        fid: 50,
        cls: 0.05
      }
    }
  }

  getAlerts() {
    return this.alerts
  }

  clearAlerts() {
    this.alerts = []
  }
}

// Global monitoring instance
export const productionMonitor = new ProductionMonitor()

// Auto-start monitoring in production
if (typeof window !== 'undefined' && process.env.NODE_ENV === 'production') {
  productionMonitor.startMonitoring()
}
