# Vulnerability Analysis – Orka PPM

**Date:** 2026-02-06  
**Scope:** Frontend (Next.js), API routes (Next.js), Backend (FastAPI), shared config and dependencies.

**Mitigations applied (2026-02-06):** JWT verification (backend + Next.js with `SUPABASE_JWT_SECRET` and `jose`), IDOR fixes on all sync APIs (auth + userId binding), column-views auth from JWT, XSS fix in `highlightMatch`, suggest-description auth, data-processor worker dangerous-string check, workflow components use `session.access_token`, dev default admin gated by `ALLOW_DEV_DEFAULT_USER`, `eval` removed from progressive-enhancement. See `.env.local.example` for `SUPABASE_JWT_SECRET` and `ALLOW_DEV_DEFAULT_USER`.

---

## Executive Summary

The analysis identified **critical** issues around authentication (JWT not verified, IDOR on user-scoped APIs), **high** risks (XSS via unescaped HTML, client-controlled user identity), and **medium**/hardening items (worker code injection pattern, unauthenticated AI endpoint, token storage). Dependencies use known-good versions; `.env` files are correctly gitignored. Addressing the critical and high findings should be prioritized before production.

---

## Critical

### 1. JWT signature not verified (Backend & Next.js API)

**Location:**  
- `backend/auth/dependencies.py` (line 65): `jwt.decode(token, options={"verify_signature": False})`  
- `backend/auth/supabase_rbac_bridge.py`, `backend/middleware/rate_limit_middleware.py`, `backend/config/database.py`: same pattern  
- Next.js: `app/api/optimized/dashboard/quick-stats/route.ts` uses `jwtDecode()` (decode only, no verify)

**Impact:** Any party can forge a JWT with an arbitrary `sub` (and other claims) and be treated as that user. Full authentication bypass and privilege escalation.

**Recommendation:**  
- Verify JWTs with the correct Supabase JWT secret (e.g. `JWT_SECRET` or Supabase project secret).  
- Use `jwt.decode(token, key, algorithms=["HS256"])` (or the algorithm your Supabase project uses) in backend and, if you must validate in Next.js, in a shared/auth helper with the same secret.  
- Do not rely on decode-only for authorization.

---

### 2. IDOR on user preferences and sync APIs

**Location:**  
- `app/api/sync/preferences/route.ts`: PUT accepts `userId` in body and updates that user’s preferences; no check that the authenticated user matches `userId`.  
- `app/api/sync/session/route.ts`, `app/api/sync/devices/route.ts`, `app/api/sync/offline-changes/route.ts`, `app/api/sync/preferences/[userId]/route.ts`, `app/api/sync/devices/[userId]/route.ts`, `app/api/sync/session/[userId]/latest/route.ts`: same pattern – `userId` from query/body/params is trusted.

**Impact:** Any authenticated (or unauthenticated, where no auth is required) user can read or overwrite another user’s preferences, session, devices, and offline changes.

**Recommendation:**  
- Resolve the authenticated user from the verified JWT (after fixing JWT verification).  
- For every sync endpoint, enforce that the requested `userId` equals the authenticated user’s ID (and return 403 if not).

---

## High

### 3. Client-controlled user identity (x-user-id)

**Location:** `app/api/v1/column-views/route.ts`  
- GET and POST use `request.headers.get('x-user-id')` to scope column views. No JWT or other server-side auth.

**Impact:** A client can send any `x-user-id` and read or create column views for other users.

**Recommendation:**  
- Remove reliance on `x-user-id`.  
- Derive user identity from the verified JWT (e.g. `sub`) after implementing proper JWT verification.

---

### 4. XSS via unescaped text in search highlight

**Location:**  
- `utils/fuzzySearch.ts`: `highlightMatch(text, query)` uses `text.replace(regex, '<mark>...$1</mark>')`. The replaced `$1` is a substring of `text`, which is not HTML-escaped.  
- `components/navigation/SearchBarWithAI.tsx`: `dangerouslySetInnerHTML={{ __html: highlightMatch(result.title, query) }}` and same for `result.description`.

**Impact:** If `result.title` or `result.description` contain HTML/script (e.g. from backend search index or user-generated content), they are rendered as HTML and can execute script (stored XSS).

**Recommendation:**  
- Escape HTML in the string that is interpolated into HTML (e.g. escape `text` before building the highlight string, or escape the final string except for the intended `<mark>...</mark>`).  
- Use a small escaping helper (e.g. replace `&`, `<`, `>`, `"`, `'`) or a trusted sanitizer; then pass the result to `dangerouslySetInnerHTML`.

---

### 5. Sync/preferences and related routes accept unauthenticated requests

**Location:** `app/api/sync/preferences/route.ts` (and other sync routes above).  
- No `Authorization` check; only `userId` in body/query.

**Impact:** Combined with IDOR, unauthenticated callers can read/update any user’s data if they know or guess `userId`.

**Recommendation:**  
- Require a valid Bearer token and verify JWT.  
- Bind operations to the verified `sub` as in (2).

---

## Medium

### 6. Unauthenticated AI endpoint (feature description)

**Location:** `app/api/features/suggest-description/route.ts`  
- POST has no auth; uses `process.env.OPENAI_API_KEY` to call an external LLM.

**Impact:** Abuse (burn API quota, cost) and potential prompt injection / misuse of the feature.

**Recommendation:**  
- Require authentication (and optionally authorization) for this route.  
- Add rate limiting per user or per IP.

---

### 7. Dangerous pattern: new Function() in data-processor worker

**Location:** `public/workers/data-processor.js`  
- `filterData`, `sortData`, `transformData` use `new Function(..., predicateStr|compareFnStr|transformFnStr)` with strings derived from `predicate.toString()` / `compareFn.toString()` in `lib/workers/data-processor-worker.ts`.

**Impact:** Currently the strings come from in-app function source, so they are not directly user-controllable. If later any user or API-supplied expression is passed into `filter`/`sort`/`transform`, this becomes remote code execution.

**Recommendation:**  
- Do not allow user- or external input to be passed as predicate/compareFn/transformFn.  
- If you need user-defined expressions, use a safe subset (e.g. a simple DSL or allowlist of operations) and never pass it to `new Function()`.

---

### 8. Inconsistent auth token source (workflows)

**Location:**  
- `components/workflow/WorkflowApprovalModal.tsx`, `components/workflow/ApprovalButtons.tsx`: use `localStorage.getItem('token')` for `Authorization: Bearer`.  
- Rest of app uses `session?.access_token` from Supabase auth.

**Impact:** Stale or wrong token (e.g. from another tab or legacy code) can be sent; possible confusion and harder security review.

**Recommendation:**  
- Use the same session source (e.g. `session?.access_token`) for workflow approval API calls.  
- If a separate token is required, document and centralize it; avoid ad-hoc `localStorage.getItem('token')`.

---

### 9. Development fallback to default admin

**Location:** `backend/auth/dependencies.py`  
- When credentials are missing or auth fails, the backend returns a default admin user (e.g. `user_id: "00000000-0000-0000-0000-000000000001"`, role `admin`).

**Impact:** If this is ever deployed with “development” behavior (e.g. wrong env or misconfiguration), unauthenticated or failed auth could still get admin access.

**Recommendation:**  
- Restrict this behavior to an explicit development mode (e.g. `DEV_NO_AUTH=true` and only when `DEBUG` or `ENV=development`).  
- In production, never return a default user; return 401 and require a valid JWT.

---

## Low / Hardening

### 10. dangerouslySetInnerHTML and innerHTML usage

**Locations:**  
- `app/providers/ThemeProvider.tsx`, `app/layout.tsx`: inline scripts (static; low risk if content is fixed).  
- `components/help-chat/MessageRenderer.tsx`: uses `ReactMarkdown` (good); ensure no custom components render raw HTML from untrusted input.  
- `lib/diagnostics/error-reporting.ts`: `modal.innerHTML = ...` with static template; ensure no user input is concatenated into the HTML string.

**Recommendation:**  
- Keep all HTML passed to `dangerouslySetInnerHTML` or `innerHTML` either static or sanitized.  
- For MessageRenderer, keep using ReactMarkdown with safe options and avoid passing unsanitized HTML.

### 11. eval() in progressive-enhancement check

**Location:** `lib/utils/progressive-enhancement.ts` (line 81): `eval('(async () => {})')` used for feature detection.

**Impact:** Minimal if the string is literal; still a bad pattern (e.g. if ever templated).

**Recommendation:** Replace with a non-eval check (e.g. `typeof Promise !== 'undefined'` or similar) if possible.

### 12. Service role key in Next.js API

**Location:** Several Next.js API routes use `SUPABASE_SERVICE_ROLE_KEY` or fallback to `NEXT_PUBLIC_SUPABASE_ANON_KEY` to create a Supabase client.

**Status (mitigated):** Audited: the service role key is only read from `SUPABASE_SERVICE_ROLE_KEY` (no `NEXT_PUBLIC_` prefix). Fallback to `NEXT_PUBLIC_SUPABASE_ANON_KEY` is the anon key, which is safe for client use. Ensure `SUPABASE_SERVICE_ROLE_KEY` and `SUPABASE_JWT_SECRET` are never added with a `NEXT_PUBLIC_` prefix.

---

## Dependencies

- **Frontend:** `package.json` uses recent versions (Next 16, React 18, Supabase client, jwt-decode). Run `npm audit` regularly; the project already has `security:audit` and `security:fix` scripts.  
- **Backend:** `backend/requirements.txt` pins versions (FastAPI, PyJWT, supabase, etc.). No obviously vulnerable versions spotted; run `pip audit` or equivalent and keep dependencies updated.

---

## Positive Findings

- `.env` and `.env.local` (and variants) are in `.gitignore`; env files are not committed.  
- Rate limiting exists for help chat (backend and client-side).  
- CORS and backend structure are present; auth is at least intended via JWT.  
- Help chat uses ReactMarkdown for assistant messages, reducing XSS from markdown.  
- Some API routes require an `Authorization` header before proxying to the backend.

---

## Recommended Priority

1. **Immediate:** Verify JWT signature everywhere (backend + any Next.js route that derives user identity).  
2. **Immediate:** Fix IDOR on all sync and user-scoped APIs by binding to verified user ID.  
3. **High:** Remove `x-user-id` and use verified JWT for column-views.  
4. **High:** Escape HTML in `highlightMatch` (and any similar paths) before using `dangerouslySetInnerHTML`.  
5. **Medium:** Add auth (and rate limiting) to `features/suggest-description`.  
6. **Medium:** Restrict dev default-admin behavior; unify workflow token source.  
7. **Ongoing:** Keep dependencies audited; avoid passing user input into `new Function()` in the data-processor worker.
